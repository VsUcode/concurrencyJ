package com.vsu.c2.part1.t4;

/** 并发容器：
 *      针对多个线程并发访问设计的
 *      通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险
 * Created by vsu on 2018/02/06.
 */


/**
 * Queue：
 *      用来临时保存一组待处理的元素。
 *      包括ConcurrentLinkedQueue，这是一个先进先出；PriorityQueue，非并发的优先队列
 *      Queue上的操作不会阻塞，如果为空将返回空值
 */

/**
 * BlockingQueue：扩展了Queue
 *      增加了可阻塞的插入和获取等操作
 *      如果为空，那么获取元素的操作将一直阻塞；如果已满，插入操作就一直阻塞
 *      生产者-消费者模式中非常有用
 */


/**
 * ConcurrentHashMap：
 *      与HashMap一样，ConcurrentHashMap也是一个基于散列的Map
 *      ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次都只能有一个线程访问容器，
 *          而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁
 */


/**
 * 额外的原子Map操作：
 *      由于ConcurrentHashMap不能被加锁来执行独占访问，因此无法使用客户端加锁来创建新的原子操作
 *          但是，一些常见的复合操作都已经实现为原子操作并在ConcurrentMap的接口中声明
 */


/**
 * CopyOnWriteArrayList：
 *      CopyOnWriteArrayList用于代替同步List，在迭代期间不需要对容器进行加锁或复制
 *      写入时复制(Copy-On-Write)容器的线程安全性在于，只要正确地发布一个事实不可变的对象，
 *          那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性
 *      写入时复制容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，
 *          因此在对其进行同步时只需确保数组内容的可见性
 *
 *      仅当迭代操作远多于修改操作时，才应该使用 写入时复制 容器
 */



public class Test2 {
}
